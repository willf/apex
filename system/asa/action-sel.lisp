;;;-*- Mode: Lisp; Package: :cl-user -*-
;;;
;;; apex/system/asa/action-sel.lisp
;;;
;;; Copyright:      See apex/LICENSE
;;; Version:        $Id: action-sel.lisp,v 1.82 2006/03/17 20:06:25 will Exp $

(in-package :common-lisp-user)


;;; This file implements a reactive planner that serves as the Action Selection
;;; Architecture (ASA) for Apex.



;;; This defines the valid transitions of tasks for Apex; for checking only.

(defparameter *current-transition-semantics* 'apex-3b14)

(def-valid-transition-network apex-3b14
  (initializing (pending))
  (pending      (enabled engaged terminated))
  (enabled      (engaged terminated))
  (engaged      (ongoing terminated))
  (ongoing      (suspended pending terminated))
  (suspended    (ongoing pending resuming terminated)) 
  (resuming     (enabled ongoing terminated))
  (terminated   (pending)))
   

;;; ---------------------------------------------------------------------------
;;; ----- ASAMain 
;;; ---------------------------------------------------------------------------
 
;;; The Action Selection Architecture main function is triggered periodically by
;;; the simulation architecture and runs repeatedly until quiescent.  It's three
;;; actions are to process enabled items on the agenda, to process new cognitive
;;; and perceptual events, including those that result from changes to the
;;; agenda, and to assign agenda tasks to resources, possibly with associated
;;; interrupts to other tasks.

;;; Interior Loop: processes all cognitive events and then all enabled agenda
;;; items.  Agenda activities may produce new events (esp. task terminations)
;;; which may in turn produce new enablements.  Quiescence = no more enabled
;;; tasks.  Middle Loop: If any interrupt requests generated by event/task
;;; processing, these are handled and control returns to interior loop; else
;;; quiescent.  Outer Loop: If there exist requests for available resources,
;;; including those freed up by interruption, these are assigned to the highest
;;; priority pending tasks with all preconditions satisfied, and then control
;;; returned to interior loop (resource assignment produced events and
;;; enablements); else quiescence.

;;; Enablement summary: Tasks with preconditions but no resource requirements
;;; are enabled in process-all-cogevents when the last precondition is
;;; satisfied.  Tasks with no preconditions or resource requirements are enabled
;;; in process-agenda as soon as they are created.  Tasks with resource
;;; requirements are enabled in process-resource-assignments when requires

;;; resources are allocated.

;;; For debugging.  May be temporary.
(defparameter *warn-asamain-reentrance* nil)
(defparameter *continue-asamain-reentrance* nil)
(defparameter *break-asamain-reentrance* nil)

(defun asamain (agent)
  (mp:with-process-lock ((process-lock agent))
    (when (agent-cycle-stage agent)
      (if *warn-asamain-reentrance*
          (format t "WARNING: asamain called on agent ~a while in ~a~%"
                  (name agent) (agent-cycle-stage agent)))
      (if *break-asamain-reentrance* (break "ASAMAIN re-entered")))
    (unwind-protect
        (when (or (null (agent-cycle-stage agent)) *continue-asamain-reentrance*)
          (let ((quiescent t))
            (setf (agent-cycle-stage agent) 'outer-loop)
            (loop 
                do (let ((quiescent-2 t))
                     (setf (agent-cycle-stage agent) 'middle-loop)
                     (loop 
                         do (let ((quiescent-3 t)) 
                              (setf (agent-cycle-stage agent) 'inner-loop)
                              (loop 
                                  do
                                    (process-all-cogevents agent)
                                    (setf (agent-cycle-stage agent)
                                      'process-agenda)
                                    (setf quiescent-3 (process-agenda agent))
                                  until quiescent-3))
                            (setf quiescent-2
                              ;; i.e. no activity
                              (not (process-interrupts agent))) 
                         until quiescent-2))
                   (setf quiescent
                     (not (allocate-resources agent))) ; i.e. no activity
                until quiescent)))
      (setf (agent-cycle-stage agent) nil))))
    

;;; !! get rid of these when trace is upgraded.. maybe add asa-event-types

(defconstant *asa-actions* 
    '(testing grabbing selecting creating executing reinstantiating 
      interrupting resuming enabling))

(defun asa-action? (x)
  (member x *asa-actions*))

a;;; ---------------------------------------------------------------------------
;;; ------ Event and precondition handling
;;; ---------------------------------------------------------------------------

;;; Cognitive events are potential enablers for tasks on the agenda. Processing
;;; an event means checking whether it corresponds to some waited-for event and,
;;; if so, whether satisfaction of that event consitutes complete (vs partial)
;;; enablement of its associated task.  Newly enabled tasks have the value of
;;; their state slot changed to "enabled."  All other side-effects of enablement
;;; are handled by agenda-management functions.

;;; Cogevents of other kinds can be generated by resources in the resource
;;; architecture (esp. including perceptual events and activity completion
;;; events) and by executing the primitive task type COGEVENT.

;;; Basic processing of a cognitive-event involves the following steps
;;;  1. Finding, all corresponding monitors for the agent (incl
;;;  resource-monitors)
;;;  2. Removing the monitor from the monitor-array
;;;  (or monitors in the alloc slot)
;;;  3. Marking as satisfied the task waitfor condition that gen'd the monitor 
;;;     (resource availability events have no corresponding waitfor condition)
;;;  4. Detemining whether all of a task's non-resource preconditions are sat'd and,
;;;     if so, initiating a resource-contention process 

;;; A single event may satisfy multiple conjs on the monitor-array,
;;; possibly even multiple for the same task.  Similarly, a single
;;; AVAILABLE event can satisfy multiple resource preconditions
;;; (presumably for separate tasks).  The process outlined above is
;;; simplified; additional mechnisms are required to handle disjunctive,
;;; joint and sequential monitors.

;;; Note: events of the form (available <resource> <value>) are matched
;;; against monitors in #'monitors of an agents
;;; resource-allocation-table slot.  These are used to determine when an
;;; enabled task that has already failed to acquired needed resources
;;; should try again.

;;; ---- Processing cognitive events

(defun process-all-cogevents (agent)    ; agent -> ()
  (setf (agent-cycle-stage agent) 'process-all-cogevents)
  (while (cogevents agent)
         (process-single-cogevent (pop (cogevents agent)) agent))
  (values))


;;; note: following function removes items from list while iterating over it
;;; note: cogevent may match multiple monitors

;;; wf. check-cogevent-match now returns a *pipe of binding sets* instead
;;; of a single binding set. 
(defun process-single-cogevent (cogevent agent)
  (let (matched?)
    (cond ((equal (first (content  cogevent)) 'available)
           (loop for monitor in
                 (gethash (first (content  cogevent))
                          (monitors (resource-allocation-table agent)))
               do 
		 (let* ((binding-pipe (check-cogevent-match cogevent monitor)))
;;;		  (format t "~a ~a ~a~%" cogevent monitor binds)
                    (when (not (eq binding-pipe empty-pipe))
                      (setq matched? t)
                      (remove-resource-monitor monitor agent)
                      (let ((task (task monitor)))
                        (log-cogevent-match cogevent task)
                        (attempt-resource-grab task))))))
          (t
           (loop for monitor in	(monitors agent)
	       when
		 (subscribes-to-p monitor (first (content cogevent)) (type-router agent))
               do
                 (let ((task (task monitor)))
                   ;; it's just possible that a monitor from a terminated
                   ;; task is still hanging around when an event comes in --
                   ;; perhaps from a terminated event from a sibling, e.g.,
                   ;; so we don't want to activated any tasks that were
                   ;; terminated.  A critical exception is a repeating
                   ;; task, whose latest rep is 'terminated' at this
                   ;; point, but still might have unsatisfied monitors (including
                   ;; the "delay" monitor used in with-min-interval tasks)
                   (if (or (and (not (terminated-p task))
				(not (suspended-p task)))
                           (restart-if task))
                       (let ((result (pipe-head
                                      (check-cogevent-match cogevent monitor))))
                         (when (and result
                                    (not (forbidden-event-match cogevent task)))
                           (setq matched? t)
                           (log-cogevent-match cogevent task)
                           (set-monitors
                            agent
                            (remove monitor (monitors agent)))
                           (remove-subscriber monitor (type-router agent))
                           (process-satisfied-monitor task monitor result cogevent)
                           (multiple-value-bind (ready hung)
                               (test-task-preconditions task)
                             (if ready
			       ;; (enable-task task)
			       (transition-task task 'enabled)
                               (when hung 
				 (transition-task task 'terminated 'failure nil 'soft)))))))))))
    (if (and (match-required cogevent) (not matched?))
        (with-readable-trace
         (warn "Unmatched cogevent: ~a~%~a" cogevent (match-rationale cogevent))))))

(defmethod terminated-p ((task task))
  (t-terminated task))

;;; log the event; mark monitor as satisfied; wind down
(defun process-satisfied-monitor (task monitor result satisfier)
  (when result
    (let ((now (current-time)))
      (setf (val monitor) t)
      (setf (monitor-time-recognized monitor)
	now)
      (setf (satisfied-by monitor) satisfier)
    (wind-down monitor)
    (extend-local-context task (binding-set result)   nil task)
    (cogevent `(monitor-satisfied ,task ,monitor ,satisfier) (agent task) :timestamp now)
    )))

;;; --- Check-cogevent-match
;;;(defun check-cogevent-match (cogevent monitor)
;;;  (when (eq (event-type cogevent)
;;;	    (first (expr monitor)))
;;;    (let* ((eventspec (content cogevent))
;;;	   (task (task monitor))
;;;	   (waitspec (replace-vars (expr monitor) (get-local-context task)
;;;				   (task-globals task))))
;;;      (pat-match waitspec eventspec))))

;;;(defun get-task-binding-val (task)
;;;  (binding-val (find-binding '+this-task+ (get-local-context task) (task-globals task))))

;;; wf. note that signal monitor returns a *pipe of monitor results*
(defun check-cogevent-match (cogevent monitor)
  (with-task (parent (task monitor))
    (signal-monitor monitor (task monitor) cogevent)
    ))

;;; --- Log-cogevent-match

;;; records the tasks which a cogevent has already matched, allowing subsequent
;;; matches to the same task to be supressed.  A task is considered to have been
;;; matched to a cogevent if a) it has an enabling waitfor precondition matching
;;; the event or b) it is terminated or reset by a second task with such a
;;; waitfor.

(defun log-cogevent-match (cogevent task)
  (push task (hits cogevent))
  (let ((td (specify-task-description task)))
    (if (member (first td) '(terminate reset))
	(push (second td) (hits cogevent)))))


;;; --- Forbidden-event-match

;;; An event may not satisfy a matched precondition for task B if it has already
;;; helped to enable (satified a precond of) a previous task A which spawned B
;;; via recurrence (i.e. B is a repetition of A).  Otherwise, the event could
;;; enable an endless string of task repetitions.

;;; Note: since cogevents are transient, it is only necessary to check previous
;;; instances of a recurrent task enabled at the current moment.  Forbidden
;;; matches will only come up for zero-duration recurrent tasks, and for tasks
;;; that recur at enable-time (rather than terminate-time which is more common).
;;; It might improve efficiency to constrain checking accordingly.

;;; ! it turns out this isnt enough.  The waitfor on a terminate-time recurrent
;;; task may not be attached to the task itself, but to a sibling or descendant
;;; (or descendant of sibling) that terminates or resets it.  What is really
;;; needed is some way of determining whether an event has indirectly
;;; enabled/terminated a previous task instance.  This may well be expensive or
;;; undecidable.  A partial fix, inserted into log-event, is to forbid matches
;;; to terminate and reset tasks that target a previously targeted task.

;;; ! Further problems of the above sort may arise from the existence of
;;; multiple identical (redundant) cogevents.

(defun forbidden-event-match (cogevent taskB)
  (let* ((targeted-task (if (member (first (description taskB)) 
				    '(terminate reset)) 
			    (second (specify-task-description taskB)))))
    (find-if #'(lambda (taskA) 
		 (or 
		  (equal taskA taskB) ;; 0-duration, recurs at terminate-time
		  (equal taskA targeted-task) ;;as above, but indirect match
		  (equal taskA (spawned-by taskB)))) ;; enable-time recur
	     (hits cogevent))))

;;; just like above ... but requires list of enabled tasks 
(defun  task-precondition-already-met-p (taskB enabled-tasks)
  (if (null enabled-tasks) nil
      (let* ((targeted-task (if (member (first (description taskB)) 
					'(terminate reset)) 
			      (second (specify-task-description taskB)))))
	(find-if #'(lambda (taskA) 
		     (or 
		      (equal taskA taskB) ;; 0-duration, recurs at terminate-time
		      (equal taskA targeted-task) ;;as above, but indirect match
		      (equal taskA (spawned-by taskB)))) ;; enable-time recur
		 enabled-tasks))))


;;; ---- Test-task-preconditions

;;; Returns a result t if all of a task's preconditions (not including resource
;;; requirements) are satisifed according to information stored in the task's WAITS
;;; slot.  Also returns an indication of whether the task is HUNG -- i.e. cannot 
;;; have its preconditions satisifed.  This occurs when all normal preconditions 
;;; are satisifed, but one or more specials in each waitclause are not; in this
;;; case, no event can trigger another precondition test. 

;;; ! It would take a number of changes but.. ideally, events that trigger an 
;;; enablement check could only cause enablement by satisfying a waitclause.
;;; Blindly checking all clauses allows enablement on the basis of some previously
;;; satisfied clause, an undesirable property for recurring tasks.

;;; ! this should call a function to change task state but there are some tricky
;;; issues that need to be resolved to avoid, e.g., resumed tasks from becoming
;;; pending, inappropriate reinstantiation -- for now, state change in response
;;; to a successful test is handled in various places

;;;(defmethod test-task-preconditions ((task task))
;;;  (let* ((preconds (monitors task))
;;;	 (unsatnorm nil) ;; true if there exists an unsatisfied normal conjunct
;;;	 (result
;;;	  (or (null preconds) ;; is there any satisfied disjunction?
;;;	      (some
;;;               #'(lambda (disjunct) 
;;;                   (every #'(lambda (conjunct) ;; is every conjunct satisfied?
;;;                              (case (monitor-type conjunct)
;;;                                (normal (cond ((val conjunct) t)
;;;                                              (t (setf unsatnorm t) nil)))
;;;                                (special (eval-spcl (expr conjunct) task))))
;;;                          disjunct))
;;;               preconds)))
;;;	 (hung (not (or result unsatnorm)))) ;; hung if only specials unsatisfied
;;;    (when (not result) 
;;;      (cogevent `(refused-enablement ,task) (agent task)))
;;;    (values result hung)))




(defmethod test-task-preconditions ((task task))
  (let* ((preconds (monitors task))
	 (unsatnorm nil) ;; true if there exists an unsatisfied normal conjunct
	 (result
	  (or (null preconds) ;; is there any satisfied disjunction?
	      (some
	       #'(lambda (disjunct) 
		   (every #'(lambda (conjunct) ;; is every conjunct satisfied?
			      (case (monitor-type conjunct)
				(normal (cond ((val conjunct)  t)
					      (t (setf unsatnorm t) nil)))
				(special (eval-spcl (expr conjunct) task))))
			  disjunct))
	       preconds)))
	 (hung (not (or result unsatnorm)))) ;; hung if only specials unsatisfied
    (when (not result) 
      (cogevent `(refused-enablement ,task) (agent task)))
    (values result hung)))



;;; --- Enable-task

;;; A task is in an enabled state if its non-resource preconditions have been
;;; satisfied, but its resource preconditions are unsatisifed or not yet
;;; tested. This function performs activities specified (in PDL) to occur at
;;; enable-time and then initiates a resource-grab.

;;(defun enable-task (task &optional suppress-reinstantiate)
(defmethod transition-task ((task task) (to (eql 'enabled)) &rest args)
  ;; ! Walter
  ;; (and *learning-on* (learn-from-task-state-change task 'enabled))
  (let ((suppress-reinstantiate (car args))
	(time (current-time)))
    (record-state-transition task 'enabled time)
    (cogevent `(enabled ,task) (agent task) :timestamp time)
  (when (and (not suppress-reinstantiate) (reinstantiate? task 'enabled))
    (live-reinstantiate task time))
  (attempt-resource-grab task)))

;;; **** Handling precondition violation

;;; In the current model, there is no direct way to handle tasks preconditions
;;; becoming unsatisifed (although they can lose control of resources and become
;;; suspended).  Future versions should treat enablement reversal as a
;;; protection violation that can either be handled as specified by the
;;; procedure, or by either of 2 general purpose mechanisms: A: wait for
;;; condition to be reachieved, B: generate reachieve goal.  Mechanisms to
;;; detect precondition reversals should automatically undo task activities that
;;; have occurred during the current ASAMain cycle including posting to the
;;; best-list and change of state to ongoing.


;;; --------------------------------------------------------------------------
;;; ------ Processing Agenda
;;; --------------------------------------------------------------------------

;;; Processing the agenda involves executing engaged tasks and clearing out
;;; terminated tasks.  Tasks are normal, special, or primitive.  Normal task are
;;; refined --- i.e.  decomposed into subtasks which are added to the agenda
;;; (plus a number of auxiliary activities such as formulating monitors for
;;; non-enabled subtasks).  Special tasks are associated with specialized LISP
;;; functions, defined by the user.  Primitives are like specials but are
;;; provided as part of the APEX procedure language.  These include: TERMINATE,
;;; REPRIORITIZE, RESET, and START-ACTIVITY.

;;; Note: Instead of the "primitive operators" found in most hierarchical
;;; planning notations, the special procedure START-ACTIVITY is used to modify
;;; the (presumably continuous) behavior of cognitive and motor resources.
;;; While the task to start the activity completes simply by resources into a
;;; new state, the activity only succeeds when the world is in the desired new
;;; state.  This scheme allows for a lot more flexibility in controlling
;;; resources --- e.g. by allowing continuous control to be simulated, and by
;;; making available the full procedure language for defining termination,
;;; interactions, etc..


(defun process-agenda (agent)
  ;;
  ;; First, prune the agenda of terminated tasks.
  ;;
  (set-tasks agent
	     (remove-if #'(lambda (a) (equal 'terminated (state a))) 
			(tasks agent)))
  ;;
  ;; Now, expand the agenda as appropriate for each task type.
  ;;
  (let ((return-value t))
     (loop for task in (tasks agent)
	do
	  (with-task (parent task)
	    (when (equal (state task) 'engaged)
	      (setq return-value nil)
	      (let* ((tstep (pstep task))
		     (forall-val (and tstep (forall tstep)))
		     (on-start (and tstep (on-start tstep)))
		     (on-end (and tstep (on-end tstep))))
		;; Make sure all resources listed in profile exist.
		(dolist (resource-name (resource-names task))
		  (add-resource-to-agent-if-necessary resource-name agent))
		;;
		;; Process on-start and on-end step clauses (other task state
		;; changes to be added soon)
		;;
		(when on-start
		  (eval
		   (cons 'progn (replace-vars
				 on-start
                                 (or (saved-context task)
                                     (get-local-context task))
				 (task-globals task)))))
		(when on-end
		  (let ((exp (replace-vars
			      on-end
                              (or (saved-context task)
                                  (get-local-context task))
			      (task-globals task))))
		    (setf (termination-action task)
		      (make-thunk (eval (cons 'progn exp))))))
		(if forall-val
		  (handle-forall-case task forall-val)
		  (case (tasktype task)
		    (normal 
		     (cogevent `(task-started ,task) agent)
		     (refine-task task))
		    (special 
		     (cogevent `(executed ,task) agent)
		     (execute-special-task task))
		    (asa-act
		     (cogevent `(executed ,task) agent)
		     (execute-asa-act-task task))
		    (primitive
                     (cogevent `(task-started ,task) agent)
                     (execute-primitive-task task))
		    (otherwise
		     (error "unknown task type ~a for ~a" (tasktype task) task))
		    ))))))
    ;; output NIL if any engaged tasks have been processed, T otherwise
    return-value))


;;; ---- Execute Special Task

;;; The APEX procedure definition language allows users to define "special"
;;; procedures which specify a body of LISP code.  Executing such a procedure
;;; involves (1) replacing context variables in the code body with their quoted
;;; bindings, and (2) terminating the task with the eval of the code as the
;;; task's return value.  Note that special tasks are non-recurring (even if
;;; otherwise specified by period clause notation in the calling context) and
;;; they always terminate with outcome=success.

;;; !: it will eventually be desirable to have an intermediate strength
;;; termination that allows recurrence as long as monitors exist and the period
;;; clause does not specify :enabled.  This will allow periodic recomputations
;;; to be triggered.

;;; ! the prohibition against (endlessly) repeating special tasks is not
;;; currently robust.  A normal task that calls all and only specials may still
;;; be recurrent, causing the same hanging behavior the prohibition was meant to
;;; avoid.  Some defense against this would be desirable.

(defun execute-special-task (task)
  (let* ((code-body (steps (proc task)))
	 (expr (replace-vars code-body (vars task) 
			     (task-globals task) :quote t))
	 (val (eval expr)))
    (transition-task task 'terminated 'success val 'soft)
    val))

;;; ---- Execute primitive task

;;; Primitive procedures are built-in (not user-defined) special
;;; procedures.  They require no time or resources to execute, except
;;; for START-ACTIVITY which takes no time but requires that its parent
;;; control a specified resource at the finest granularity (10).
;;; Primitive task execution is handled in every way like special task
;;; execution, except that the code to evaluate is accessed directly (by
;;; the LISP reader) rather than through the step slot of a user-defined
;;; procedure).

(defconstant *primitives-list* 
    '(terminate termiante start-activity reprioritize reset
      cogevent hold-resource release-resource suspend resume
      ))

(defmethod id ((x symbol))
  x)

(defmethod resource-names ((task task))
  (replace-vars (mapcar #'car (profile task))
		(vars task)
		(task-globals task)))

(defmethod execute-primitive-task ((task task))
  (with-task task
    (let ((resources (resource-names task)))
      (extend-local-context task (list (make-binding '+this-task+ task)) t)
      (when resources
	(dolist (resource resources)
	  (add-resource-to-agent-if-necessary resource (agent task))
	  ;; Check if the task controls the resource...
	  (if (not (controls-resource task resource *default-ownership-level*))
	    (error "Attempt to control resource ~a by ~a without ownership~%"
		   resource task))))
      (let ((now (current-time)))
        (with-task task
          (start-resource-activity-from-primitive task now resources)))
      task)))

(defmethod execute-asa-act-task ((task task))
  (let ((action (replace-vars (description task) (get-local-context task)
			      (task-globals task)))
	(agent (agent task))
	(returnval nil))
    (case (description-action action)
      ((terminate termiante)
       (if (eq (parent task) (second action))
	 (progn
	   (transition-task (second action) 'terminated (third action) (fifth action) 'soft))
	 (progn
	   (transition-task (second action) 'terminated (third action) (fifth action) 'hard))))
      (start-activity
       (cond ((controls-resource task
                                 (description-resource action)
                                 *default-ownership-level*)
	      (setf returnval
		(start-resource-activity task agent (rest action) (description-resource action))))
	     (t (error "Attempt to control resource ~a by ~a without ownership" 
		(second action) task))))
      (reset 
       (reset-task (second action) (and (> (length action) 2) (third action))))
      (reprioritize (attempt-resource-grab (second action)))
      ;; add suspend/enable when authorized -- waf
      (suspend 
       ;; (hard-suspend-task (second action)))
       (transition-task (second action) 'suspended 'hard))
      (resume
       ;;(unsuspend-task (second action) ))
       (transition-task (second action) 'resuming))
      ((cogevent generate-event) (cogevent (second action) agent))
      (hold-resource (hold-resource task (rest action)))
      (release-resource (release-apex-resource task (rest action))))
    (transition-task task 'terminated 'success returnval 'hard)
    task
    ))


;;; --- Notes on REPRIORITIZE
;;; 
;;; In the current implementation, a task initiates a resource grab when
;;; it is created or when (as a pending or suspended task) it is
;;; signalled that a needed resource has become available.  It would be
;;; desirable to have grabs initiated whenever some event increases the
;;; priority of a needy task or decreases the priority of a current
;;; owner.  For discrete priority changes, this can be accomplished with
;;; the REPRIORITIZE operator and an appropriate WAITFOR clause.  For
;;; continuous changes, particularly due to increase in urgency as a
;;; deadline approaches, there is currently no way to trigger a grab.
;;; An approximation might be using a reprioritize with a refractory
;;; (recovery) value, but the mechanisms for positive inhibition might
;;; be top weak to make this efficient (overly repetitious grabs).
;;;
;;; - Should cause all enabled/suspended child tasks to reprioritize
;;; - Should reverse pending interrupts on the best list

;;; --- START-ACTIVITY support functions
;;;
;;; The function start-resource-activity is defined with the resource architecture
;;; since the action-seleciton architecture (this file) does not commit to any
;;; particular resources or to declared resources having any attributes other
;;; than exclusive ownability.

(defun controls-resource (task resource level)
  (cond ((rootp task) nil)
	((directly-controls task resource level) t)
	(t (controls-resource (parent task) resource level))))

(defun directly-controls (task resource level)
  (let ((own-entry 
	 (find-if #'(lambda (e) (and (equal (res-owner-task e) task)
                                     (equal (res-owner-resource e) resource)))
		  (owners (resource-allocation-table (agent task))))))
    (and own-entry 
	 (let ((range (res-owner-range own-entry))) 
	   (and (>= level (first range)) (<= level (second range)))))))




;;; 
;;; ------ Termination

;;; For efficiency, removal of a terminated task from the agenda is
;;; delayed until the function PROCESS-AGENDA is run.  All other
;;; termination effects (listed below) are carried out by
;;; TERMINATE-TASK.  Terminations are caused in one of two ways: (1) by
;;; executing a task on the agenda whose activity description (slot) has
;;; the form: (terminate ?task ?outcome >> ?returnval); or (2) as a
;;; side-effect of terminating a parent task.  Termiantions of the first
;;; sort are "soft" meaning that periodicity notations associated with
;;; the task may cause the task to be immediately reinitiated upon
;;; termination.  Terminations of the latter sort are "hard" meaning
;;; that such annotations are ignored.

;;; Termination entails the following actions (not in order):
;;;
;;; 1. Recursively terminate [hard] all children and remove associated monitors 
;;; 2. Reinstantiate if period clause declares task :recurrent [soft only]
;;; 3. Remove resource ownerships and generate associated availability signals
;;; 4. Remove best entries  (assume only normals have profiles)
;;; 5. Remove task from all bump and interrupt lists so they don't revive
;;; 6. Add returnval (if any) to parent context
;;; 7. Set state to terminated (needed to remove and to resolve hanging refererences)
;;; 8. Signal termination
;;; 9. stop any activity started by descendant of task (not including itself)
;;;     -- if task started activity directly, then leave the activity alone
;;; 10. Execute termination action.
;;; 11. stopping any logging. 
;;
;;(defun terminate-task (task outcome returnval ttype &optional now)
(defmethod transition-task ((task task) (to (eql 'terminated)) &rest args)
  (destructuring-bind (outcome returnval ttype &optional now) args
    (when (not (eq 'terminated (state task)))
    (let ((now (or now (current-time)))
          (agent (agent task))
	  (activities (find-all-dependent-activities (children task)))
          (reinstantiate?
           (and (eq ttype 'soft)
                (eq (reftime task) 'terminated)
                (eval-spcl (restart-if task) task)
                (or (null (rep-state task))
                    (and (rep-state task)
                         (eval-spcl (rep-state task) task))))))
      (setf (t-terminated task) now)
      (unless reinstantiate?
        (cogevent `(terminated ,task ,outcome) (agent task) :timestamp now))
      
      (dolist (act activities) (stop-resource-activity act agent)) ; #9
      ;; stops activities other than those started by the task itself
      ;;  (these have to go on after the start action itself terminates)
      (dolist (subtask (children task)) 
	(transition-task subtask 'terminated 'success nil 'hard)) ;;#1
      (set-monitors agent
		    (remove-if #'(lambda (monitor) (equal task (task monitor))) 
			       (monitors agent)))
      (let ((returnvar (returnvar task))) ;;#6
	(when returnvar 
	  (extend-local-context  task (pat-match returnvar returnval))))
      (remove-ownerships task) ;;#3
      ;;releases and signals release of resources owned by task
      ;; ! Walter
      ;; (and *learning-on* (learn-task-end task)) 
      
      ;; for majick reasons, the RECORD-STATE-TRANSITION has to
      ;; be here -- probably after the terminate task of children 
      (record-state-transition task 'terminated now reinstantiate?) ;; #7
      
      
      (expunge-from-best task) ;;#4/#5
      (let ((table (monitors (resource-allocation-table agent))));;#1
	(maphash #'(lambda (key monitors) 
		     (setf (gethash key table) 
		       (remove-if #'(lambda (monitor) 
				      (equal task (task monitor))) 
				  monitors)))
		 table))
      (when reinstantiate? 
	;; note: reverses state-change (#7) since struc reused
	(reinstantiate-task task now))	; #2
      (dolist (policy (logging-policies task))
	(stop-sv-logging-policy (task-memory task)
				(car policy))) ; #11
      (if (termination-action task)	; #10
	(funcall (termination-action task)))))))
      
(defun find-all-dependent-activities (tasklist)
  (if (null tasklist)
      nil
    (mapcan #'(lambda (task)
		(if (action task)
		    (list (action task))
		  (find-all-dependent-activities (children task))))
	    tasklist)))


;;; ---- Hard suspend 

;;; Cause a task to suspend from an external source (another task).
;;; 
;;; Suspension entails the following actions (not in order):
;;; numbering is the same as termination
;;;
;;; 1. Recursively suspend all children
;;  2. [not applicable]
;;; 3. Remove resource ownerships and generate associated availability signals
;;; 4. Remove best entries  (assume only normals have profiles)
;;; 5. Remove task from all bump and interrupt lists so they don't revive
;;; 6. [not applicable]
;;; 7. Set state to suspended (needed to remove and to resolve hanging refererences)
;;; 8. Signal interruption
;;; 9. stop any activity started by descendant of task (not including itself)
;;;     -- if task started activity directly, then leave the activity alone

;;; ! may need to stop-activities descending from suspended task.. letting them
;;; keep going for now
(defmethod transition-task ((task task) (to (eql 'suspended)) &rest args)
  (destructuring-bind (suspension-type &optional agent when) args
    (ecase suspension-type
     (hard
      (when  (member (state task) '(ongoing enabled))
	(let ((now (current-time))
	      (agent (agent task))
	      (activities (find-all-dependent-activities (children task))))
	  (signal-interruption task (agent task) now) ; #8
	  (dolist (act activities) (stop-resource-activity act agent)) ; #9
	  ;; stops activities other than those started by the task itself
	  ;;  (these have to go on after the start action itself terminates)
	  (dolist (subtask (children task)) 
	    (transition-task subtask 'suspended 'hard)) ;;#1
	  (remove-ownerships task) ;;#3
	  
	  ;;releases and signals release of resources owned by task
	  (record-state-transition task 'suspended now) ;;#7
	  (expunge-from-best task) ;;#4/#5
	  )))
      ;; otherwise a 'soft' suspend. just transition
      (soft
       (remove-ownerships task) ;; was remove-all-resource-ownerships
       ;; ! Walter
       ;; (and *learning-on* (learn-from-task-state-change task 'suspended))
       ;; KMD: This is what I think we should do (as suggested by comment
       ;; above this function), but not sure how to test if this does the
       ;; right thing.
       ;; (dolist (act (find-all-dependent-activities (children task)))
       ;;   (stop-resource-activity act agent))
       (record-state-transition task 'suspended when)
       (signal-interruption task agent when)
       ))))

;;;
;;; when a task is suspended, to uninterrupt it, enable its leaf tasks
;;; 

;;(defun unsuspend-task (task)
(defmethod transition-task ((task task) (to (eql 'resuming)) &rest args)
  (declare (ignore args))
  (when (eql (state task) 'suspended)
    (record-state-transition task 'resuming (current-time) t)
    (if (not (children task))
      (transition-task task 'enabled t)
      (dolist (child (children task))
	(transition-task child 'resuming)))))

;;; ---- Reset 

;;; Reset causes a task to effectively terminate and immediately
;;; restart.  The primitive takes one optional argument, an expression
;;; that determines whether the task restarts with currently satisfied
;;; waitfor conditions reinstated (T) or left satisfied (NIL, the
;;; default if no arg supplied).

;;; In the reinstate case, resetting causes a task to terminate (hard)
;;; and then be reinstantitated as if it were recurrent.  In the default
;;; no-reinstate case, what happens depends on the task's current state.
;;; If the task is pending, there is no effect; a reset would reproduce
;;; the current situation.  If the task is ongoing, reset hard
;;; terminates all subtasks, sets state to pending, and tries a resource
;;; grab. Suspended tasks are handled identically, except any related
;;; resource monitors are removed.  Terminated tasks are simply reset to
;;; pending and given a grab attempt.

;;; !nothing currently handles the case where an ongoing/suspended
;;; task's precondition is violated, causing the task to reset and wait
;;; for the precondition to be reachieved.

(defun reset-task (task &optional reinstate)
  (let ((now (current-time)))
    (cogevent `(reset ,task) (agent task) :timestamp now)
    (cond (reinstate
           (progn
             (transition-task task 'terminated 'reset nil 'hard now)
             (reinstantiate-task task now)))
          (t
           (let ((state (state task)))
             ;; ! Walter
             ;; (and *learning-on* (learn-from-task-state-change task 'pending))
             (record-state-transition task 'pending now)
             (when (member state '(ongoing suspended))
               (dolist (subtask (children task)) 
                 (transition-task subtask 'terminated 'success nil 'hard))
               (remove-ownerships task))
             (when (equal state 'suspended)
               (expunge-from-best task))
             (when (test-task-preconditions task) ;currently, will always succeed
               ;;(enable-task task t)
	       (transition-task task 'enabled t))
             ))))) ;; not using enable-task to avoid reinstantiation


;;; -- Remove-ownerships

;;; By default, deallocates all resources from a task and generates availability
;;; signals for waiting tasks.  Optionally, removes only a single ownership.

(defun remove-ownerships (task &optional resname)
  (if (equal 'ongoing (state task))
      (generate-resource-availability-signals task resname))
  (let ((agent (agent task)))
    (setf (owners (resource-allocation-table agent))
      (remove-if 
       #'(lambda (entry) 
	   (and (equal task (third entry))   ;; if entry is for selected task
		(or (not resname)            ;; if for any resource
		    (equal resname (first entry)))))  ;; if for selected resource
       (owners (resource-allocation-table agent))))))

;;; --- Hold-resource

;;; Increases the resource requirements for a task and then triggers a check to
;;; compete for the new resource.  This could cause interruption of the task.
;;; However, its normal use is to allow bottom-up assertion of some new
;;; requirement as resource needs change or become more certain.  expected args
;;; are resource-name and then optionally :ancestor <n> where n > 0 refers to
;;; the nth ancestor of the task that called this primitive.  By default, n = 1
;;; -- i.e. the immediate parent task.

(defun hold-resource (task args)
  (let* ((resname (first args))
	 (n (if (and (rest args) (equal (second args) :ancestor))
		(third args)
	      1))
	 (ancestor (nth-ancestor task n)))
    (add-resource-to-agent-if-necessary resname (agent task))
    ;; ! Walter
    ;; (and *learning-on* (learn-time-in-slack-end (parent task) resname))
    (add-to-profile ancestor `(,resname 10 10))
    (attempt-resource-grab ancestor)))

(defun add-to-profile (task requirement)
  (if (not (assoc (first requirement) (profile task) :test 'equal))
    (setf (profile task) 
          (cons requirement (profile task)))))

(defun release-apex-resource (task args)
  (let* ((resname (first args))
	 (n (if (and (rest args) (equal (second args) :ancestor))
		(third args)
	      1))
	 (ancestor (nth-ancestor task n)))
    (if (not (member resname (resource-names (agent task))))
        (error "Attempt to release nonexistent resource ~a in ~a~%"
               resname (agent task)))
    ;; ! Walter
    ;; (and *learning-on* (learn-time-to-slack-end ancestor resname))
    ;; (and *learning-on* (learn-time-in-slack-start ancestor resname))
    (remove-ownerships ancestor resname)
    (remove-from-profile ancestor resname)
))

(defun remove-from-profile (task resname)
  (setf (profile task)
        (remove-if #'(lambda (x) (equal (first x) resname)) (profile task))))

;;; -- Expunge-from-best

;;; Removes best entries to task from (best
;;; (resource-allocation-table agent)) and removes all references to
;;; task in INT lists and BUMP lists in other best entries.

;;; Note: the following could be made more efficient by exploiting the
;;; fact that tasks without resource req's (null profiles) will not have
;;; or be contained in best entries

(defun expunge-from-best (task)
  (let ((agent (agent task)))
    (setf (best (resource-allocation-table agent))
      (mapcan 
       #'(lambda (entry)
	   (if (equal task (first entry))
	       nil
	     (list  ;;wrapper for mapcan
	      (list (first entry)
		    (remove task (second entry))
		    (remove-if
                     #'(lambda (b) (equal (first b) task)) (third entry))))))
       (best (resource-allocation-table agent))))))


;;; -----------------------------------------------------------------------------
;;; ----- Detecting and resolving resource conflicts
;;; -----------------------------------------------------------------------------

;;; ---- Attempt-resource-grab

;;; An enabled task attempt to acquire needed resources in four conditions: 1)
;;; as it first becomes enabled (possibly at create-time if no preconditions);
;;; 2) when a resource it needs becomes newly available; 3) when the primitive
;;; operator reprioritize is executed on the task; 4) during a n-way (n>2)
;;; competition in which a higher priority competitor becomes bumped, raising
;;; the possibility that whatever task beat it doesn't need the contested
;;; resource. 

;;; Tasks with no resource requirements are immediately put in the
;;; engaged state to trigger execution.  Resource-demanding tasks
;;; compete with whatever tasks (if any) currently control those
;;; resources and with any "best" tasks about to gain control.  If the
;;; task competes successfully for all needed resources, it is entered
;;; as the best competitor for each on the best entry in the agent's
;;; resource-allocation-table slot, along with a list of tasks that will
;;; have to be interrupted if the task remains best when the ASAMain
;;; interior loop becomes quiescent.  Previous best tasks are bumped
;;; from the best list.

;;; Winning a resource competition (even against no competitors) only gives a
;;; task "best" status --- resources are assigned to tasks that maintain best
;;; status until the middle loop becomes quiescent.  (Note: interruptions are
;;; generated after the interior loop becomes quiescent, but this returns
;;; control to the interior loop which may enable responses to the interrupt;
;;; resources are only allocated after responding tasks have been given a chance
;;; to compete for resources with the tasks that intitated the interrupts.)

;;; Note: testing an ongoing task is to determine if it is still the best user
;;; of needed resources, esp. after its resource needs have changed.

(defun attempt-resource-grab (task)
  (let ((agent (agent task)))
    (if (not (member (state task) '(suspended ongoing)))
	(select-procedure-for-task task))  ;;defines task's resource profile
    (if (not (member (state task) '(enabled suspended ongoing)))
	'grab-aborted-for-inactive-task  ;; ! should be error?
      (cond
       ((null (profile task))
	(resume-or-engage task)
	'no-resources-required)
       (t
	(multiple-value-bind (success conflicts1)
	    (compare-to-bests task)
	  (cond ((not success)             ;;compete against best tasks
		 (handle-fail-against-best task conflicts1)
		 'not-best-contender)
		(t
		 (multiple-value-bind (success2 conflicts2)
		     (compare-to-owners
                      task
                      (owners (resource-allocation-table agent)))
		   (cond ((not success2)       ;;compete against owners
			  (handle-fail-against-owner task conflicts2)
			  'not-better-than-current-owner)
			 (t
			  (let ((new-best `(,task ,conflicts2 ,conflicts1)))
			    (pushnew new-best
                                     (best (resource-allocation-table agent)) 
				     :test 'equal)
			    (mapc #'(lambda (c) 
				      (bump-best-task (first c) new-best)) 
				  conflicts1)
			    'best-so-far))
			 ))))))))))


;;; Note: When the selected procedure is a primitive or special, the resource
;;; grab results in task enablement since nor resoruce requirements exist in
;;; either case

;;; Note: for determining what to do with a task after a conflict, 4 cases must
;;; be handled, covering 6 task conditions (owner|best|challenger x won|lost).
;;; The input arg for attempt-resource-grab is always a challenger.  Summary:
;;;
;;;   - challenger loses to current owner: make monitor for challenger
;;;   - challenger beats current owner: challenger is best; put owner on int list
;;;   - challenger loses to current best: put challenger on bump list
;;;   - challenger beats current best: challenger is best; prev best on bump list

;;; Note: new best must be added to resource list before old one is bumped.  This
;;; allows tasks that were themselves bumped by the old to get a new resource grab
;;; attempt in which the new task is present as a competitor.

;;; -- Engage Task

;;; Engaging a task requires setting its state to 'engaged, recording a
;;; timestamp, and optionally, instantiating a copy of the task.  Endless
;;; engage-time reinstantiations are possible if the task comes into existence
;;; enabled.  To partially prevent this, enable-time repetitions cannot have
;;; their :enabled parameter (from the period clause) evaluate to non-nil.  A
;;; more comprehensive prevention may be desirable in which no repeat takes
;;; place unless either the new task has unsatisfied preconditions or it has
;;; resource requirements.

;; (defun engage-task (task)
(defmethod transition-task ((task task) (to (eql 'engaged)) &rest args)
  (declare (ignore args))
  ;; ! Walter
  ;; (and *learning-on* (learn-from-task-state-change task 'engaged))
  (let ((now (current-time)))
    (record-state-transition task 'engaged now)
    (setf (t-started task) now)
    (when (reinstantiate? task 'started)
        (live-reinstantiate task now))))


;;; ---- Compare-to-owners 

;;; Checks for conflicts between challenger task and current
;;; resource-owning tasks.  If the challenger is higher priority than
;;; all conflicting owners, the set of such owners is returned (to be
;;; interrupted if the challenger survives as best).

;;; Note that if an owner task loses to the challenger, the current
;;; framework does not require maintaining any information about the
;;; basis for this loss; a resource monitor of the form (available
;;; ?anyresource ?anylevel) will be generated for the interrupted task.
;;; Similarly, when the challenger loses, there is no need to record the
;;; particular owner it lost to.  The monitor generated for the
;;; challenger only requires information about the resource conflict
;;; from which the failed challenge arose.

(defun compare-to-owners (challenger owners-list)
  (let ((examined nil)
	(conflicts nil)  ;;conlficting tasks with less priority than TASK
	(outcome t))     ;;t if challenger > all conflicting owner tasks
    (loop for owner-entry in owners-list
	do (let ((task (third owner-entry)))
	     (when (not (member task examined))    ;;look for redundancy
	       (multiple-value-bind (preference conflict-set)
		   (task-preference challenger task)
		 (cond ((equal preference task)
			(setf outcome nil)  
			(setf conflicts (first conflict-set))
			(return)) 
		       ((equal preference 'no-conflict)
			(push task examined))
		       (t   
			(push task examined)			
			(push task conflicts)))))))
    (values outcome conflicts)))

;;; ---- Compare-to-bests

;;; Checks for conflicts with current best tasks.  If the challenger is
;;; higher priority than all conflicting best tasks, the function
;;; returns a list of best tasks to bump of the form ((<task> <resource>
;;; <low> <high>)..).  If the challenger loses to any best, a
;;; characterization of the conflict of the form (<task> <resource>
;;; <low> <high>) is returned.

;;; Note: even though a challneger may conflict with a best task over
;;; multiple resources, it is only important to keep track of one
;;; (arbitrarily selected) conflict in order to produce a resource
;;; monitor for the loser.

(defun compare-to-bests (challenger)
  (let* ((agent (agent challenger))
	 (best-list (best (resource-allocation-table agent)))
	 (examined nil)
	 (conflicts nil)  ;;conlficting tasks with less priority than TASK
	 (outcome t))     ;;t if challenger > all conflicting tasks in group 
    (loop for best-entry in best-list
	  do (let ((task (first best-entry)))
	       (when (not (member task examined))    ;;look for redundancy
		 (multiple-value-bind (preference conflict-set)
		     (task-preference challenger task)
		   (cond ((equal preference task)
			  (setf outcome nil)  
			  (setf conflicts (cons task (first conflict-set)))
			  (return)) ;;return from loop with conflicts discovered so far
			 ((equal preference 'no-conflict)
			  (push task examined))
			 (t         
			  (push task examined)			
			  (push (cons task (first conflict-set)) conflicts)))))))
    (values outcome conflicts)))


;;; -- Bump-best-task 

;;; Removes task from the best list.  Tasks that were themselves bested by this
;;; task (lost as challenger or bumped) are given a new resource grab attempt.
;;; Allowing this attempt has two important results.  First, previously bested
;;; tasks may now be viable since different resources may be at issue between
;;; them and the current best than for the current best and whatever task is
;;; causing it to be bumped.  Second, and perhaps more importantly, if the grab
;;; attempt for an "unbumped" tasks fails, the previous information about what
;;; resource to wait for may become obsolete.  Information from a newly failed
;;; grab attempt will more accurately reflect which resource is at issue, thus
;;; allowing a useful resource monitor to be established; otherwise, the task
;;; might wait indefinitely long to be executed, even though its needed resource
;;; is available.

;;; Tasks bumped by this function may have survived long enough to have
;;; generated interrupts as indicated by the intial symbol 'interrupted
;;; in items on the <int> list of the task's bump-entry.  These <int>
;;; items are transferred to the new best task so that when resources
;;; are allocated, an appropriate resource monitor can be generated to
;;; enable resumption.

;;; Note: if BEST is ever made into an explicit task state, bumping from
;;; the best state should cause a task to revert to its previous state.

(defun bump-best-task (task new-best-entry)
  (let* ((agent (agent task))
	 (resource-allocation-table (resource-allocation-table agent))
	 (old-best-entry (assoc task (best resource-allocation-table))))
    (setf (best (resource-allocation-table agent))
      (remove old-best-entry (best resource-allocation-table)))
    (setf (second new-best-entry)
      (append (second new-best-entry) (completed-interrupts old-best-entry)))
    (mapc #'(lambda (bump-entry) (attempt-resource-grab (first bump-entry)))
	  (third old-best-entry)) ;;grab attempt for all bested tasks
    ))	

;;; Note: Items on int-list are task structures or lists of the form
;;; (interrupted <task>)

(defun completed-interrupts (int-list)
  (loop for i in int-list 
      when (and (consp i) (equal 'interrupted (first i)))
      collect i))  


;;; --- Handle-fail-against-x

;;; When a challenger task fails a resource grab against a current
;;; owner, the task should remain in its pending or suspended state; a
;;; resource monitor of the form (available <res> <low>) should be
;;; generated to cause another grab attempt when <res> becomes available
;;; at level <low> (the largest time-scale granularity at which the
;;; current owner denies the contested resource).

;;; Against a best task (current best contender for a resource), the
;;; failed challenger should be added to the "bump" list for the task's
;;; best entry.  If the best entry is itself bumped, the challenger gets
;;; another grab attempt.

;;; Note: the <conflict> parameter differs for owner and best conflicts;
;;; best conflicts include as the first item, a pointer to the task from
;;; which the conflict arose

(defun handle-fail-against-owner (task conflict)
  (add-apex-resource-monitor 
   (make-monitor `(available ,(first conflict) ,(second conflict)) task)
   (agent task)))

(defun handle-fail-against-best (task conflict)
  (let ((best-entry 
	 (assoc (first conflict)
                (best (resource-allocation-table (agent task))))))
    (if best-entry
        (setf (third best-entry)
          (cons (cons task (rest conflict)) (third best-entry))))
    ;;adds new bump-entry to best-entry of form (<task> <res> <low> <high>)
    ;;note that first list-item in conflict is the winning (best) task
    conflict
    ))


;;; ------ Task preference

;;; Returns 2 values: 1) the higher priority of task1 and task2 (or 'no-conflict
;;; if one is a direct ancestor of the other or if either requires no
;;; resources); 2) a resource conflict set of the form ((<resource> <lowval>
;;; <highval>)..) where the val parameters define a range of temporal
;;; granularity levels for the conflict.  (See description of PROFILE clause).

;;; It would be good idea for task1 to always be the challenger task, where
;;; task2 is the current owner or current best contender.  This prevents
;;; thrashing when tasks have equal priority and get multiple resource grab
;;; attempts.  It also is efficient since the overhead of (unnecessarily)
;;; displacing the current owner/best is avoided.


(defun task-preference (task1 task2)
  (let ((relation (task-relation task1 task2)))
    (if (member relation '(ancestor descendant identity))
        (values 'no-conflict nil)
      (let ((rc (resource-conflict-set task1 task2)))
        (if (null rc)
            (values 'no-conflict nil)
          (progn
            (log-event `(conflict-detected ,task1 ,task2 ,rc) :agent (agent task1))
            (let ((winner nil) 
                  (loser nil)
                  (ranker (select-ranking-task task1 task2 relation)))
              (if ranker
                  (setf winner ranker)
                (if (> (compute-priority task1) (compute-priority task2))
                    (setf winner task1)
                  (setf winner task2)))
              (setf loser (if (equal task1 winner) task2 task1))
              (cogevent `(conflict-resolved :winner ,winner :loser ,loser) 
                        (agent task1))
              (values winner rc))))))))

;;; determined relation of two tasks in the task hierarchy.  If the tasks are
;;; identicial, identity is returned.  If task1 is a descendant or ancestor of
;;; task2, those values are returned.  Otherwise, a list of two tasks is
;;; retunred specifying the the first-uncommon-ancestors of the tasks --
;;; i.e. the tasks' sibling-ancestors (see sib-ancestors)

(defun task-relation (task1 task2)
  (if (equal task1 task2)
      'identity
    (let* ((anclist1 (ancestor-list task1))
           (anclist2 (ancestor-list task2)))
      (cond
       ((member task1 anclist2) 'descendant)
       ((member task2 anclist1) 'ancestor)
       (t (sib-ancestors task1 anclist1 task2 anclist2))))))

;;; sib-ancestors finds a pair of sibling tasks in the ancestry of the
;;; two input tasks.  The input tasks are included in the anccestry
;;; in this case.  So e.g. if the two tasks are themselves siblings, 
;;; they will be the return value for the function.

(defun sib-ancestors (task1 anc1 task2 anc2)
  (cond
   ((and anc1 anc2 (equal (car anc1) (car anc2)))
    (sib-ancestors task1 (cdr anc1) task2 (cdr anc2)))
   ((and anc1 anc2) (list (car anc1) (car anc2)))
   ((and anc1 (null anc2)) (list (car anc1) task2))
   ((and (null anc1) anc2) (list task1 (car anc2)))
   (t (list task1 task2))))  ;; both ancestor lists null

(defun ancestor-list (task &optional ancs)
  (if (rootp task)
      (cons task ancs)
    (ancestor-list (parent task) (cons task ancs))))

;(defun ancestor-list (task)  ;;ancestors includes self
;  (if (rootp task)
;      (list task)
;    (cons task (ancestor-list (parent task)))))


(defun nth-ancestor (task n)
  (cond ((rootp task) task)
	((= n 0) task)
	(t (nth-ancestor (parent task) (- n 1)))))

;;; --- Resource-conflict-set
;;;
;;; Returns set of resource requirements over which two tasks conflict.
;;; Requirements are from task profiles, each a list of objs with form:
;;; (<res> <dur> <cont>).  The <dur> and <cont> args are integer values
;;; in the range 1-10, with <dur> <= <cont>.  Returns are list of the
;;; form ((<res> <low> <high>) ..) where <low> and <high> represent the
;;; range within which the tasks conflict over <res>.

(defun resource-conflict-set (task1 task2)
  (let ((req1 (specify-task-slot task1 'profile))
	(req2 (specify-task-slot task2 'profile)))
    (and req1 req2     ;; no conlict if either task has no requirements
	 (loop for r1 in req1
	     when 
	       (let ((r2 (find-if #'(lambda (r) (equal (first r1) (first r))) req2)))
		 (when r2
		   (let ((ov (range-overlap (cdr r1) (cdr r2))))
		     (and ov (list (first r1) (first ov) (car (last ov)))))))
	     collect it))))

;;; -- range-overlap
;;;
;;; Checks for overlaps on integer ranges a and b; assumed lower of 2
;;; vals first.  This function is efficient for the intended number
;;; ranges (1 to 10) but would be horrendous for large ranges.  Returns
;;; a list of overlapping values including intermediate values.

(defun range-overlap (a b)  
  (loop for v from (first a) to (second a)
      when (and (>= v (first b)) (<= v (second b)))
      collect v))

;;; ------- Selection higher ranked task

;;; Rank is a variant of priority, but is dynamically scoped rather than 
;;; globally scoped.  Ranks are assigned within a procedure.  If tasks
;;; A and B are derived from steps of the same procedure and A has a 
;;; superior (lower) rank, then A and all descendants of A have precendence
;;; in resource conflicts over B and all descendants of B.  Rank
;;; supercedes priority.

;;; The ancsibs (ancestor siblings) parameter is a list of two sibling tasks
;;; that are ancestors ot task1 and task2 (in this case the tasks are
;;; considered to be ancestors of themselves).

(defun select-ranking-task (task1 task2 ancsibs)
  (flet ((compute-rank (tsk) (eval-spcl (rank tsk) tsk)))
    (if (consp ancsibs) ;; true if task1 and task2 are not direct ancestors
        (let ((rank1 (compute-rank2 (first ancsibs)))
              (rank2 (compute-rank2 (second ancsibs))))
          (if (and rank1 rank2)  ;; ranks are not necessarily defined
            (cond ((< rank1 rank2) task1)
                  ((> rank1 rank2) task2)
                  ((= rank1 rank2) nil))))))) ;; lower rank is preferred

(defun compute-rank2 (task)
  (eval-spcl (rank task) task))

;;; ------- Compute priority

;;; Returns priority of task.  Only tasks that are ongoing, enabled, or
;;; suspended have non-zero priority.  Local priority is the max of priorities
;;; derived from a task's priority bases (criterial events that need to be
;;; avoided, defined by PRIORITY clauses).  A task's priority is the max of its
;;; local-priority and its parent (inherited) priority, plus any interrupt-cost
;;; bonus; however, a suspended parent contributes no priority to descendants,
;;; even though it has priority of its own in order to compete for resources and
;;; eventually resume.  Children of suspended tasks can still be ongoing unless
;;; otherwise specified (termination/suspension) in procedure.

;;; If a task's priority value is updated, the new value along with the current
;;; importance bonus and a timestamp are recorded in the task's priority field.

;;; Note: it may be possible to avoid priority-compute if time-stamp on
;;; last compute equals current-time.  But maybe not also.. need to
;;; check if priority can fluctuate over single call to ASA-Main.

;;; Note: this assumes that interrupt-cost is not inherited.  The ideal
;;; approach is complicated: interrupt-cost heritability depends on whether
;;; the time-cost of interruption is absorbed into slack of higher level
;;; tasks (which are presumably longer and varying in demands on resources)

(defun compute-priority (task)
  (if (rootp task)
      0
    (let* ((parent (parent task))
	   (parent-pr (if (equal (state parent) 'suspended) 
			  0  ;; zero priority inherited from suspended parent
			(compute-priority parent)))) 
      (let* ((bonus (local-interrupt-bonus task))
	     (local-prs (compute-local-priorities task bonus (agent task)))
	     (priority (apply #'max (cons parent-pr local-prs))))
	(setf (priority task) (list priority bonus (current-time)))
	priority))))


(defun local-interrupt-bonus (task)
  (if (equal (state task) 'ongoing)
      (or (eval-spcl (icost task) task) 0)
    0))

(defun compute-local-priorities (task bonus agent)
  (let ((ref (compute-task-refractory-val task))
	(subj-wkld (get-subjective-workload agent))
	(local-binds (get-local-context task))
	(global-binds (task-globals task))
	(t-create (t-created task)))  ;;timestamp for task creation
    (mapcar 
     #'(lambda (basis)
	 (if (equal 1 (length basis)) ;;basis is fixed number or variable
;;;	     (* ref (replace-vars (first basis) local-binds global-binds))
	     (* ref (eval-spcl (first basis) task))
	   (let ((urg (basis-urgency basis local-binds global-binds t-create))
		 (imp (basis-importance basis local-binds global-binds)))
	     (basis-priority urg imp subj-wkld ref bonus))))
     (priority-parameters task))))


;;; ---- Basis computations

;;; Bases are defined by priority clauses and represented in
;;; priority slots.  Multiple bases are possible for a single step
;;; (and therefore a single task).  The priority slot thus contains a
;;; list of basis values, each a list of the following form (<event>
;;; (urgency <expr>) (importance <expr>)).

(defun basis-importance (basis binds global-binds)
  (replace-vars (second (assoc 'importance (cdr basis))) binds global-binds))

(defun basis-urgency (basis binds t-create global-binds)
  (update-urgency (replace-vars (second (assoc 'urgency (cdr basis))) 
				binds global-binds)
		  t-create))

;;; computes a current urgency value given an initial urgency, the
;;; timestamp when that urgency was current, and a log scaling factor
;;; specified for the domain.

(defparameter *time9* 1000)

(defun update-urgency (u-init t-init)
  (let* ((t-now (current-time))
	 (t-available-init (* *time9* (expt 2 (- 9 u-init))))
	 (deadline (+ t-init t-available-init))) 
    (if (>= t-now deadline)
	10.0  ;;if already past the deadline then u-now = maxurgency
      (let* ((t-available-now (- deadline t-now))
	     (urgency-basis (+ 9.0 (log *time9* 2)))
	     (u-now (round (- urgency-basis (log t-available-now 2)))))
	u-now))))

;;; ---- Compute task refractory value

;;; Refractory value is the proportion of the time needed to recover
;;; full priority after the last execution of the task.  Tasks
;;; refractory periods are defined by the PERIOD clause.  If the full
;;; ref-period has passed, the value is 1.0.


(defun compute-task-refractory-val (task)
  (let ((now (current-time))
	(per (eval-spcl (refract task) task)) ;;refractory period
	(last (t-last task)))
    (cond ((or (null per) (zerop per)) 1.0)  ;;task has no refractory period
	  ((> now (+ last per)) 1.0) ;;refractory period completed
	  ((= now last) 0.0) ;;task just terminated
	  (t (/ (- now last) per))))) ;;refractory period partially completed

;;; ---- Basis priority

;;; Computes the priority contribution by a single basis.  Terms:
;;;  I:  importance (neg. utility of suffering basis event)
;;;  U:  urgency (est. time until basis event occurs)
;;;  S:  subjective-workload (likelihood of task squeeze)
;;;  R:  refractory value (0 to 1: fraction of recovery time already passed)
;;;  Int-cost: inheritable importance bonus (only to ongoing tasks)

;;; (- 1 (/ 1 (+ 1 x) where x is U or I is a "discount term" in the
;;; function that minimizes the priority of bases with very low
;;; urgency or importance

;;; The function is based on scales for U, I, S, and int-cost of 0 to 10
;;; (1 to 9 for S).  The (10-S) term represents an inversion of the S
;;; value so that as S gets higher, the term and thus the effect of U
;;; gets lower; this complements the S term which increases the effect I
;;; as S gets higher.

;;; Dividing the sum of the I and U terms by 9 normalizes the resulting
;;; value to the range 0-9.  The result, considered a log value, is then
;;; added to interrupt cost (also a log val).

(defun basis-priority (U I S R int-cost)
  (log+ (/ (* R (+ (* I S (- 1.0 (/ 1.0 (+ 1.0 U))))
		(* U (- 10.0 S) (- 1.0 (/ 1.0 (+ 1.0 I))))))
	9)
	int-cost 2)) 

;;; ------------------------------------------------------------------
;;; Reinstantiation of recurrent tasks
;;; ------------------------------------------------------------------

;;; -- Reinstantiable

;;; To be eligible for reinstantiation, a task must be blocked from
;;; immediate/effortless re-enablement, thus preventing the system from
;;; generating endless 0 duration repetitions and thereby hanging.
;;; Condition 2 is satisfied if either (a) the task has preconditions
;;; (not supressed by :enabled), (b) it has non-nil resource
;;; requirements, (c) decomposes into subtasks, at least one of which
;;; has preconditions or resource requirements, or (d) it's a primitive
;;; task with either a specified duration or update interval.  To test
;;; for resource requirements and subtask properties, it is assumed that
;;; the recurring task will select the same procedure as the original;
;;; this may be wrong, but only one 0 cost repetition will slip by.

(defun reinstantiable (task)
  (or (profile task)                   ;; (b)
      (and (eq 'primitive (tasktype task)) ; (d)
           (or (duration (proc task))
               (update-interval (proc task))))
      (and (not (eval-spcl (rep-state task) task)) ;; (a)
	   (let ((waitfors (waitfors (pstep task)))) 
	     (and waitfors 
		  (not (equal :and (first waitfors))))))
      (some #'reinstantiable (children task))))  ;; (c)


;;; --- Live Reinstantiate

;;; Function causes a copy of a live (non-terminated) task to be reinstantiated.
;;; This should be contrasted with the function REINSTANTIATE.

;;; When restarting a recurrent task at terminate-time (q.v. TERMINATE-TASK),
;;; the old task-structure is reused; this allows all references to it by other
;;; tasks to resolve correctly.  This approach is not desirable for enable-time
;;; and engagement-time restarts since the old task structure is still on the
;;; agenda.  The inability to resolve references to these repeated tasks is
;;; probably OK since such recurrence is really only intended to allow sustained
;;; event-monitoring (while a previous instance of the event is being handled).
;;; Hopefully, coordination between such tasks will never be required.

;;; Note that live tasks cannot be reinstantiated in an enabled state (as in the
;;; PERIOD option :ENABLED).

(defun live-reinstantiate (task &optional (now (current-time)))
  (when (reinstantiable task)
    ;;excludes vars bound by cogevents that satisfy task preconditions
    (stabilize-activity-description task)
    (let* ((old-ctxt (get-local-context task))
           (new-ctxt (unbind-all (vars-to-unbind task) (get-local-context task))))
      ;; Context used by on-start and on-end clauses in subsequent processing
      (setf (saved-context task) old-ctxt)
      (set-local-context task new-ctxt)
      (let ((new (create-one-new-task (pstep task) (proc (parent task))
				      (parent task))))
	(setf (t-last new) now)
	(setf (earliest-start new) (1+ now)) ;; must start later ...
	(setf (spawned-by new) task)
	(setf (repitition-number new)
	  (1+ (repitition-number task)))
	(log-event `(reinstantiated ,task) :agent (agent task))
	(instantiate-task new new-ctxt)))))

;;; Binds variables in a task's activity description, making it immune to changes to
;;; bindings from live-reinstantiated tasks.

(defun stabilize-activity-description (task)
  (setf (description task) (specify-task-slot task 'description)))

(defparameter *support-period-clause* t)

(defun support-period-clause (period-clause)
  (when (and  *support-period-clause* period-clause)
    (warn "Replace deprecated PERIOD clause with REPEATING or RESPONDING"))
  *support-period-clause*)


;;; ---- Reinstantiate task

;;; Reinstantiation means making an active, though not necessarily enabled task,
;;; from a previous task instance.  It is important to differentiate
;;; reinstantiations of terminated tasks from those of active tasks.  The former
;;; type, those handled by this function, are considered repetitions.  A
;;; convenient way to handle them is to recycle (revive) the representation of
;;; the task, changing its state from "terminated" and perhaps making other
;;; changes.  The latter type are handled by the function ENGAGE-TASK because
;;; they only occur (currently) as the previous task is engaged.  The purpose is
;;; to allow passive monitors to remain "observant" after the event they are
;;; looking out for has been observed and the response is still ongoing. In this
;;; case, it is not possible or desirable to reuse the previous task instance
;;; since that instance is still active on the agenda.


(defun reinstantiate-task (task &optional (now (current-time)))
  (labels ((handle-timed-repetition ()
             (when (min-rep-interval task)
               (let* ((delayspec (eval-spcl (min-rep-interval task) task))
                      (delayval (duration-read delayspec))
                      (then (+ now delayval)))
                 (add-delay-monitor task delayspec delayval then)))))
    (when (reinstantiable task)
      (setf (t-last task) now)
      (setf (t-created task) now)
      (setf (children task) nil)
      (setf (t-last task) (current-time))
      (setf (t-created task) (current-time))
      (setf (children task) nil)
      (setf (earliest-start task) (1+ now))
      (incf (repitition-number task))
      (setf (fragment-number task) 0)
      (if (support-period-clause (period (pstep task)))
          (add-periodicity-info task (period (pstep task)) 
                                ;;only needed to re-eval :recovery
                                (get-local-context task)))
      (cond ((repitition (pstep task))
             (setf (reftime task) 'terminated)
             (add-repitition-info task (repitition (pstep task)) 
                                  ;;only needed to re-eval :recovery
                                  (get-local-context task)))
            ((response-policy (pstep task))
             (setf (reftime task) 'enabled)
             (add-response-policy-info task (response-policy (pstep task)))))
      (cond ((eval-spcl (rep-state task) task)  ; if task to restart enabled
             (setf (monitors task) nil) ; make all preconditions satisfied
             (handle-timed-repetition))
            (t
             (setf (monitors task) (waitfors (pstep task))) ;;revive preconds
             (handle-timed-repetition)
             (set-local-context
              task
              (unbind-all (vars-to-unbind task) (get-local-context task)))))
      (log-event `(reinstantiated ,task) :agent (agent task))
      ;; precond of last task instance
      (instantiate-task task (get-local-context task)))))
  
(defun add-delay-monitor (task delayspec delayval then)
  (declare (ignore delayval))
  (setf (monitors task)
	(list (cons `(:function (>= (current-time) ,then))
		    (car (monitors task)))))
  (schedule delayspec (inform `(tick clock = ,then))))

(defun unbind-all (vars bs)
  ;; list(var) * binding-set -> binding-set
  (if (null vars)
      bs
    (unbind-all (cdr vars) (unbind (car vars) bs))))

;;; --- Reinstantiate?

;;; Checks if live-reinstantiate should be done: ok if restart requested
;;; for current context and if precondition restoration required in 
;;; current context.  Not requiring resotration risks infinite looping.

(defun reinstantiate? (task phase)
  (and (equal phase (reftime task)) ;;engage-time restart specified 
       (eval-spcl (restart-if task) task)  ;;restart condition satisfied
       (not (eval-spcl (rep-state task) task))))


;;; ------------------------------------------------------------------
;;; --- Handle Forall Case
;;; ------------------------------------------------------------------

;;; Tasks with a FORALL notation are decomposed into a set of tasks
;;; corresponding to items in a specified list.  This allows, e.g., a
;;; procedure to specify that all objects returned in a visual searchmap
;;; should be examined.  The arg parameter should be of the form (<var>
;;; in <list>) where <var> appears in the activity and <list> is
;;; bound to a value of type list.

(defun handle-forall-case (task arg)
  (let* ((var (first arg))
         (global-vars (task-globals task))
         (val-list (replace-vars (third arg) (get-local-context task) 
                                 global-vars))
         (activity (description task)))
    (cond ((not (listp val-list))
           (error "Cannot apply FORALL to non-list ~a~%" val-list))
          (val-list
           (let ((steps nil) (steptags nil))
             (dolist (val val-list)
               (let* ((tag (gentag "STEP"))
                      (act (replace-vars activity
                                         (list (make-binding var val)) 
                                         global-vars)))
                 (push `(step ,tag ,act) steps)
                 (push tag steptags)))
             (setf (proc task) (make-forall-proc activity steps steptags))
             (setf (vars task) (copy-binding-list (get-local-context task)))
             ;; ! Walter
             ;; (and *learning-on* (learn-initialized-task task))
             (refine-task task)))
          (t (transition-task task 'terminated 'success nil 'soft)))))


(defun make-forall-proc (activity steps tags)
  (let ((idx-step `(index ,(cons 'forall activity)))
	(termstep `(step ,(gentag "STEP") (terminate) 
			 (waitfor ,@(mapcar #'make-variable tags)))))
    (make-procedure (cons idx-step (cons termstep steps)))))

;;;create proc, set as proc for input task, refine task
;;;create: make step for v in list, activity bound by specifying [v] then rest;
;;;   vars=task vars; proctype=normal
    


;;; ---------------------------------------------------------------------------
;;; ----- Task specification and refinement
;;; ---------------------------------------------------------------------------

;;; Specification refers to process of making an abstractly specified
;;; task more specific, either by assigning values to unbound variables
;;; or by decomposing a task into subtasks (organized by a
;;; long-term-memory procedure).  Specifying all variables is a
;;; necessary but not sufficient step for decomposition (aka
;;; refinement), since that phase may also have to wait for certain
;;; events to occur.  The ability to refinement is hallmark feature of
;;; sketchy planners.

;;; ------ Procedure retrieval

;;; If task is a primitive such as TERMINATE, sets the task type to
;;; 'primitive.  Otherwise, returns first matching procedure in the proc
;;; library, if any, along with bindings generated by the match.  The
;;; retrieval index must be fully specified (cannot contain variables).

;;; Note that the procedure retrieval process is only loosely coupled
;;; with refinement.  Selection may occur and then later reoccur with a
;;; new result before refinement ever occurs.  This allows
;;; resource-requirements to be guessed at a relatively early stage
;;; (when all variables specified); committment to a particular method
;;; (procedure) still occurs late when more information is available to
;;; guide the choice.

;;; The need to have early and periodically updated information about a
;;; task's resource requirements conflicts with the need to delay
;;; committment to a procedure until as late as possible.  Resolving
;;; this involves performing procedural retrieval mutliple times and
;;; allowing for the possibility that the selection will change.  The
;;; first retrieval occurs when the task's (non-resource) preconditions
;;; are satisfied and the first resource grab attempt is made.
;;; Subsequent resource grabs invoke new retrievals.  In principle
;;; (ideally), retrieval should occur at any indication that the best
;;; selection might have changed, or at frequent intervals if
;;; indications are not guaranteed to exist and be detected.


(defun select-procedure-for-task (task)
  (let* ((global-vars (task-globals task))
	 (index (specify-task-description task))
	 (all-procedures (procedures (agent task))))
    (if (member (first index) *primitives-list*)
	(setf (tasktype task) 'asa-act)
      (multiple-value-bind (proc binds)
	  (find-best-proc-match index all-procedures)
	(if (null proc)
            (handle-procedure-retrieval-failure task)
	  (progn
	    (cogevent `(procedure-retrieved ,task --> ,proc) (agent task))
	    (setf (proc task) proc)
            ;; ! Walter
            ;; (and *learning-on* (learn-initialized-task task))
	    (setf (tasktype task) (proctype proc)) ;;special or normal
	    (setf (profile task) 
	      (replace-vars (profile proc) binds global-vars))
	    ;; policy creation & enabling
	    (setf (logging-policies task)
	      (replace-vars (logging-policies proc) 
			    binds global-vars))
	    (dolist (policy (logging-policies task))
	      (apply #'start-sv-logging-policy (task-memory task) policy))
	    ;; 
	    (setf (vars task) binds))) ;;makes proc vars avail to subtasks
	  proc))))

(defun find-best-proc-match (index procedures)
  (let ((proc nil) (binds nil) (match 20))
    (dolist (p procedures)
      (let* ((b (pat-match (index p) index))
	     (m (and b (match-lvl b))))  
	(when (and m (> match m))  ;;lower match-val is better match
	  (setf proc p) (setf binds b) (setf match m)
	  (if (= m 0) (return)))))
    (values proc binds)))
	   

(defun match-lvl (bindlist)
  (if (or (null bindlist) (equal bindlist '((t . t))))
      0
    (+ 1 (match-lvl (cdr bindlist)))))

;;; -- Handle procedure retrieval failure

;;; ! Retrieval failure should probably be interpreted as a terminating
;;; outcome.. possibly a successful one.

(defun handle-procedure-retrieval-failure (task)
  (error "No procedure found to specify ~a" task))  


;;; -- Specify task description

;;; A task's description is used as an index for retrieving and
;;; parameterizing a procedure.  Variables included in the description
;;; are to be replaced with values at retrieve-time.  Note that variable
;;; values can change between successive procedure retrievals for a
;;; task, possibly causing different procedures to be selected at
;;; different times

;;; ! since some tasks reference others in their descr, it might be useful
;;; to do this function recursively (or maybe one deep)

(defun specify-task-description (task)
  ;; ! Deprecated (handle-all-lisp-callouts
   (resolve-resource-references
    (replace-vars (description task) 
		  (append (apply-selection-rule task) (get-local-context task))
		  (task-globals task))
    (agent task)))

;;; --- Resolve resource references

;;; ! this is a stopgap measure since it won't handle variant references such
;;; as dominant-hand (an alias) or any-free-hand (a context-sensitive function).
;;; there are currently several ways to link an agent to its resources including
;;; type-specific slots in an agent subtype (e.g. human-agent), elements of the
;;; human-agent slot func-relations slot, and the components slot.  This is
;;; going to have to be sorted out...

(defun resolve-resource-references (expr agent)
  (cond ((consp expr)
	 (mapcar #'(lambda (item) (resolve-resource-references item agent)) expr))
	(t (let ((res (find-if #'(lambda (c) (equal (type-of c) expr))
			       (components agent))))
	     (or res expr)))))

;;; --- Apply selection rule

;;; PDL provides a select clause specifying a rule for variable
;;; assignment that applies (only) to the specification of a task
;;; description.  This is useful primarily for influencing procedure
;;; selection for the task.  Note that the binding applies only to the
;;; transient specification and does not add information to the local
;;; binding context.  However, the binding does take precedence over any
;;; alternative binding in the local context.

(defun apply-selection-rule (task)
  (when (select task)
    (let* ((var (first (select task)))
	   (code (replace-vars (second (select task)) (get-local-context task)
				(task-globals task)))
	   (val (eval code))) 
      (list (make-binding var val)))))


;;; ------ Refine Task

;;; Task refinement is the process of decomposing a task into subtasks.  This
;;; function assumes that 
;;;   1) method-selection --- i.e. the job of deciding which procedure should be
;;;      used as the template for generating subtasks --- has been accomplished
;;;   2) all vars needed to specify the task description are bound
;;;   3) all preconditions are satisfied and all required resources allocated

;;; only valid for standard non-primitive tasks.  Assumes task is
;;; already OK'd to be refined --- i.e. either no res. reqs. or all reqs
;;; satisifed.

;;; Requires two passes: first to set references, then to instantiate new tasks

(defun refine-task (task)
  (let ((proc (proc task)))
    (if (not (equal (proctype proc) 'normal))
	(error "Tried to refine non-normal task ~a" task)
      (multiple-value-bind (ctxt newtasks)
	  (create-new-tasks task proc) ;;pass 1
	(extend-local-context task ctxt t)  ;; store bindings in parent vars slot
	(dolist (task-2 newtasks)    ;;pass 2
	  (instantiate-task task-2 (get-local-context task-2)))
        ;; ! Walter
	;; (and *learning-on* (start-task-learning task))
	
	(record-state-transition task 'ongoing (current-time))
	))))


;;; ! Walter
;;; (defun start-task-learning (task)
;;;  (learn-from-task-state-change task 'ongoing)
;;;  (start-duration-timing task)
;;;  (dolist (res (profile task)) 
;;;    (learn-time-to-slack-start task (first res))))


;;; --- Create-new-tasks

;;; First of two passes: Generate a task and associated task-ref variable for
;;; each step in selected procedure.  Generate initial local context including
;;; vars generated in method selection, task-refs, and +this-task+.

;;; !Should check for possible merge.  If merge test passed, task already on
;;; agenda should be referenced and possibly modified instead of creating new
;;; task.

(defun create-new-tasks (parent proc)
  (let ((newtasks nil)
	(taskrefs nil))
    (dolist (step (steps proc))
      (multiple-value-bind (new ref)
	  (create-one-new-task step proc parent)
	(push new newtasks)
	(push ref taskrefs)))
    (values (cons (make-binding '+this-task+ parent) taskrefs) newtasks)))

;;; ! not clear whether vars is needed in above (maybe should use for
;;; periodicity info)


(defun create-one-new-task (step proc parent)
  (let* 
      ((now (current-time))
       (new (make-instance 'task 
	      :description (activity step) 
	      :parent parent 
	      :proc proc
	      :pstep step 
	      :priority-parameters (criteria step)
	      :rank (rank step)
	      :agent (agent parent)
	      :select (select step)
	      :t-created now
	      :icost `(log+ 2 ,(interrupt-cost step) 
			    ,(interrupt-cost proc))
	      :monitors (waitfors step) ;;waits slot-val is temporary
	      :reftime 'terminated :refract 0 :t-last -10000 ;; defaults
	      :returnvar (returnvar step)))
       (ref (make-binding (make-variable (tag step)) new)))
    (if (support-period-clause (period step))
        (add-periodicity-info new (period step) (get-local-context new)))
    (when (or (repitition step) (response-policy step))
      ;; by default, the task restarts
      (setf (restart-if new) t)
      (cond ((repitition step)
             (setf (reftime new) 'terminated)
             (add-repitition-info new (repitition step) (get-local-context new)))
            ((response-policy step)
             (setf (reftime new) 'enabled)
             (add-response-policy-info new (response-policy step)))))
    (log-event `(task-created ,new) :agent (agent parent) :timestamp now)
    (values new ref)))

;;; vars in operands specified as needed except for recovery time

(defun add-periodicity-info (task clause vars)
  (cond ((null clause) nil)
	((not (keywordp (first clause))) (add-periodicity-info task (cdr clause) vars))
	(t
	 (case (first clause)
	   (:recovery  (setf (refract task) 
			 (replace-vars (second clause) vars (task-globals task))))
	   (:recurrent (setf (restart-if task) (clause-operand clause)))
	   (:enabled   (setf (rep-state task) (clause-operand clause)))
	   (:reftime   (setf (reftime task) (clause-operand clause))))
	 (add-periodicity-info task (cdr clause) vars))))

(defun add-repitition-info (task clause vars) ; -> ()
  (setf (reftime task) 'terminated)
  (cond ((atom clause) (values))
	((not (keywordp (first clause))) (add-repitition-info task (cdr clause) vars))
	(t
         (let ((operand (clause-operand clause)))
           (case (first clause)
             (:enabled
              (setf (rep-state task) (clause-operand clause)))
             (:with-recovery
               (setf (refract task) 
                 (replace-vars (second clause) vars (task-globals task))))
             (:for-new
              (setf (vars-to-unbind task)
                (valid-unbinable-vars (clause-operand clause t) task)))
             (:with-min-interval
                 (setf (min-rep-interval task) (clause-operand clause)))
             (:while
               (setf (restart-if task) `(and ,operand ,(restart-if task))))
             (:until
               (setf (restart-if task) `(and (not ,operand) ,(restart-if task))))))
	 (add-repitition-info task (cdr clause) vars))))

(defun add-response-policy-info (task clause) ; -> ()
  (cond ((atom clause) (values))
	((not (keywordp (first clause)))
         (add-response-policy-info task (cdr clause)))
	(t
         (let ((operand (clause-operand clause)))
           (case (first clause)
             (:for-new
              (setf (vars-to-unbind task)
                (valid-unbinable-vars (clause-operand clause t) task)))
             (:while
               (setf (restart-if task) `(and ,operand ,(restart-if task))))
             (:until
               (setf (restart-if task) `(and (not ,operand) ,(restart-if task))))))
	 (add-response-policy-info task (cdr clause)))))

(defun valid-unbinable-vars (vars task)
  ;; list(any) * task -> list(symbol)
  (flet ((reject (e m)                    ; any -> list(symbol)
           (warn "Ignoring ~a in :for-new clause of task ~a: ~a" e task m)
           (valid-unbinable-vars (cdr vars) task)))
    (if vars
        (let ((e (car vars)))
          (cond ((not (variable-p e))
                 (reject e "not a variable"))
                ((not (eq :free (variable-type e)))
                 (reject e "not a free variable"))
                ((not (member e (variables-in (waitfors (pstep task)))))
                 (reject e "not in step's waitfor"))
                (t (cons e (valid-unbinable-vars (cdr vars) task))))))))

  
(defun clause-operand (c &optional as-list)
  (or (null (cdr c)) (keywordp (second c)) (collect-operands (cdr c) as-list)))

(defun collect-operands (e &optional as-list)
  ;; list * opt(bool) -> atom + list
  ;; Support function for clause-operand.  If there's a single operand,
  ;; return it (wrapping it in a list if as-list).  If there are
  ;; multiple, collect them into a list.  Assumes E is nonempty and that
  ;; its first element is not a keyword
  (cond ((or (null (cdr e))
             (keywordp (second e)))
         (if as-list (list (car e)) (car e)))
        (t
         (cons (car e) (collect-operands (cdr e) t)))))

  

;;; Note that not all task slots are set at creation-time.  State and
;;; waits are set by INSTANTIATE-TASK.  Proc, priority, and profile are
;;; set at method-selection time.  Children, vars, and t-started are set
;;; when the task is enabled and decomposed into subtasks.  T-last is
;;; set when/if the task is reinstantiated.


;;; --- Instantiate-task

;;; Second of two-pass task-refinement process, making use of reference
;;; resolutions to sibling tasks generated in pass-1.  All aspects of
;;; task creation not requiring these references handled in pass-1
;;; (CREATE-NEW-TASKS).  Function must: Generate monitor structures and
;;; put them on the agent monitor-array; add new task to agenda; set
;;; task state.

;;; If all task preconditions are satisfied at instantiation-time, it is given a
;;; resource-grab-attempt (if a normal task) or enabled (if special or
;;; primitive).  The resource grab has different outcomes: if the task has no
;;; resource requirements, it is enabled; if all required resources are
;;; available or can be acquired in contest, it is made the "best" contender for
;;; these resources --- and will be allocated those resources if it remains best
;;; through the resource allocation phase of ASAMain; if one or more resources
;;; are unavailable, a resource monitor is generated and the task remains
;;; pending.

;;; Note: preconditions satisfied if either 1) there are no preconditions or 2)
;;; the only preconditions are "special" (can be eval'd at no cost) and these
;;; are satisifed

(defun instantiate-task (task vars)
  (setf (state task) 'initializing)
  (let ((agent (agent task)))
    (multiple-value-bind (new-monitors new-waitsval)
	(gen-waitstrucs (monitors task) task vars)
      (setf (monitors task) new-waitsval)

      ;; ! Walter
      ;; (and *learning-on* (learn-from-task-state-change task 'pending))
      (record-state-transition task 'pending (current-time)) 
      
      (setf (children (parent task))
	(union (list task) (children (parent task)))) ;; as below
      (add-task-if-necessary task agent)
      ;; Clear special context potentially saved by caller
      (setf (saved-context task) nil)
      
      (if (test-task-preconditions task)
	(progn
	  ;;(enable-task task)
	  (transition-task task 'enabled))
	(progn
	  (set-monitors agent (append new-monitors (monitors agent)))))
      task)))

;;; -- Gen-waitstrucs
;;;
;;; Creates a disjunctive list containing conjunctive lists of WAITCONJ
;;; structures based on the contents of a procedure step's waitfors
;;; slot.  The conjunctive list may contain the keyword :and, signifying
;;; that all subsequent conjuncts are of type special (need to be
;;; eval'd).

;;; ! note: currently, all non-special wait conditions must be fully
;;; specified at task creation time.  It would probably be useful to
;;; allow waitvals and monitors to acquire specialization as variables
;;; are bound.  This would allow earlier steps to determine more
;;; specifically what later steps are waiting for.

(defun gen-waitstrucs (waitforlist task vars)
  (let ((monitors nil)
	(waitval nil))
    (setf waitval
      (mapcar 
      #'(lambda (disj)         ;;loop over disjunctive precondition lists
	  (let ((type 'normal))
	    (mapcan            ;;loop over conjunctive list of preconds
	     #'(lambda (conj)  ;;  create monitor and waitconj for each
		 (cond ((equal conj :and) (setf type 'special) nil)
		       (t
			(let* ((wait (replace-vars conj vars (task-globals task)
						   :quote (equal type 'special)))
			       (newmon (make-monitor wait task :type type)))
			  (if (equal type 'normal)
			      (push newmon monitors))
			  (list newmon)))))
	     disj)))
      waitforlist))
    (values monitors waitval)))

;;;(defun gen-waitstrucs (waitforlist task vars)
;;;  (let ((mons (loop for wf in waitforlist 
;;;		  collecting
;;;		    (make-monitor (replace-vars wf vars (task-globals task))
;;;				  task ))))
;;;    (values mons (list mons))))



;;; -----------------------------------------------------------------------------
;;; ------ Interrupt generation
;;; -----------------------------------------------------------------------------

;;; BEST task entries listed in (best *resources*) have the
;;; following form: (<task> <ints> <bumps>).  Interrupts are generated
;;; for all tasks in <ints> that have not previously been interrupted.
;;; (Previous interruptions can occur in two cases: (1) when a task
;;; appears on the interrupt list for multiple best tasks, all but the
;;; first are redundant and should be removed from their interrupt list;
;;; (2) when a task is interrupted, it remains on the interrupt list in
;;; a modified form --- (interrupted <task>) instead of <task> --- and
;;; should be ignored until resource allocation time when a resource
;;; monitor for <task> will be generated.

;;; Interruption involves the following actions:
;;; - generating an event of the form (available <res> <lvl>) for each
;;;   ownership level of each resource owned by the task.  Since child
;;;   tasks may have overlapping ctl of resources, some of these
;;;   availabilities are not strictly true; however, declaring them free
;;;   has the desirable effect of making child tasks vulnerable to
;;;   challenge
;;; - removal of the task's resource ownerships from (owners *resources*)
;;; - setting the task state to SUSPENDED
;;; - generating an event of the form (interrupted <tag>).  Note: this event
;;;   should be signalled after the availability events for reasons of efficiency
;;; - update the best <int> entry to reflect that the interrupt has taken place

;;; ------ Process-interrupts

;;; Generates interruptions and outputs list of tasks that were (newly)
;;; interrupted.

(defun process-interrupts (agent)
  (let ((now (current-time))
        (new-interrupts nil))
    (dolist (best-entry (best (resource-allocation-table agent)))
      ;;redundant interrupts; remove to prevent mult monitors
      (let ((remove-list nil)) 
	(dolist (task (second best-entry)) ;;tasks to interrupt for given best entry
	  (when (typep task 'task)  ;;exclude if of form (interrupted <task>)
	    (case (state task)
	      (suspended  ;;check if already interrupted
	       (push task remove-list))
	      (ongoing
	       (transition-task task 'suspended 'soft agent now)
	       ;; moved to 
	       ;;(remove-ownerships task) 
               ;;(record-state-transition task 'suspended now)
	       ;;(signal-interruption task agent now)
	       (push task new-interrupts))
	      (terminated nil)
	      (t (error "Tried to interrupt ~a" task)))))
	(setf (second best-entry) 
	      (loop for task in (second best-entry)
		    when (consp task) 
		    collect task  ;;retain if in form (interrupted <task>)
		    when (and (not (consp task)) (not (member task remove-list)))
		    collect `(interrupted ,task))) ;;put in form above 
	)) 
    new-interrupts))

(defmethod signal-interruption ((task task) (agent agent) timestamp)
  (if (eq 'primitive (tasktype task))
      (cogevent `(interrupted ,task) agent :timestamp timestamp
                :match-required t
                :match-rationale "Interrupted primitives should be handled!")
    (cogevent `(interrupted ,task) agent :timestamp timestamp)))


;;; --- generate-resource-availability-signals

;;; Task resource requirements are defined by profiles of the form
;;; ((<res> <duration> <continuity>) ..) where <res> is a particular
;;; resource, <duration> is an value from 1 to 10 approximating how long
;;; the resource will be needed by the task, and <continuity> a value
;;; from 1 to 10 denoting how long a duration another task must require
;;; the same resource for it to constitute a significant interruption.
;;; Higher values in this notation represent exponentially DECREASING
;;; intervals.

;;; Resources availability occurs within certain temporal ranges,
;;; parameterized by the duration and continuity values.  E.g. the gaze
;;; resource might become available in the range of 3 to 8.  The
;;; following function signals availability individually at all levels
;;; within this range.

(defun generate-resource-availability-signals (task &optional resname)
  (let* ((profile (specify-task-slot task 'profile))
	 (agent (agent task))
	 (reqlist (if resname `((,resname 10 10)) profile)))
    (dolist (req reqlist)
      (let ((resource (first req))
	    (dval (second req))
	    (cval (third req)))
	(cogevent `(resource-deallocated ,resource :from ,task) agent)
        ;; ! Walter
        ;; (and *learning-on* (learn-resource-deallocated task resource))
	(loop for i from dval to cval
	    do 
	      (cogevent `(available ,resource ,i) agent :suppress-log t)
	      )))))

;;; --- Remove-all-resource-ownerships
;;;
;;; redundant with remove-ownerships
;;;
;;;(defun remove-all-resource-ownerships (task)
;;;  (let ((agent (agent task)))
;;;    (setf (owners (resource-allocation-table agent))
;;;      (loop for own-entry in (owners (resource-allocation-table agent))
;;;	  when (not (equal task (third own-entry)))
;;;	  collect own-entry))))


;;; -----------------------------------------------------------------------------
;;; ------ Resource allocation
;;; -----------------------------------------------------------------------------

;;; ----- Allocate Resources

;;; Resources are allocated to all current BEST tasks (on (best
;;; *resources*)).  It is assumed that (1) all resources required by
;;; best tasks are currently available --- i.e. no ongoing task owns
;;; them; and (2) no best task conflicts with any other best task.

;;; Allocation involves the following steps:
;;;  - asserting new resource ownerships in (owners *resources*)
;;;  - posting resource monitors for all tasks bumped or interrupted by
;;;    a best task
;;;  - setting the task state of best tasks to engaged (if was pending)
;;;    or ongoing (if was suspended)

;;;  - clearing the best list to reflect absence of unresolved resource conflicts

(defun allocate-resources (agent)
  (let* ((resource-allocation-table (resource-allocation-table agent))
	 (best-entry-list (best resource-allocation-table)))
    (when best-entry-list
      (dolist (best-entry best-entry-list)
	(let ((task (first best-entry))
	      (ints (second best-entry))
	      (bumps (third best-entry)))
	  (assert-new-ownerships task)
	  (generate-bump-res-monitors bumps agent)
	  (generate-int-res-monitors ints agent)
	  (resume-or-engage task)))
      (setf (best resource-allocation-table) nil)
      t))) ;;returns t to violate quiescence in ASAMain if best entries exist


;;; --- Assert-new-ownerships

;;; Change resource ownerships listed in (owners *resources*)

(defun assert-new-ownerships (task)
  (let* ((agent (agent task))
	 (resource-allocation-table (resource-allocation-table agent)))
    (setf (owners resource-allocation-table)
      (append 
       (mapcar #'(lambda (req)
		   (let ((res (first req)) (dur (second req)) (cont (third req)))
		     (cogevent `(resource-allocated ,task ,res) (agent task))
                     ;; ! Walter
                     ;; (and *learning-on* (learn-resource-allocated task res))
		     (list res `(,dur ,cont) task)))
	       (specify-task-slot task 'profile))
       (owners resource-allocation-table)))))

;;; --- generate-bump-resource-monitors

;;; Creates monitors to trigger a resource grab for given bumped task (or failed
;;; challenger) and then places it on (monitors *resources*)

(defun generate-bump-res-monitors (bump-list agent)  ;;!task param not needed
  (dolist (bump-entry bump-list)
    (add-apex-resource-monitor
     (make-monitor `(available ,(second bump-entry) ,(third bump-entry))
		   (first bump-entry))
     agent)))

;;; --- Generate-interrupt-resource-monitors

;;; Creates monitors to trigger a resource grab for given interrupted
;;; task and then places it on (monitors *resources*).  At the time
;;; of interruption, is is not known which task will end up controlling
;;; the interrupted task's resources, and thus it cannot be known which
;;; resource to wait on.  Therefore, interrupted tasks are given
;;; open-ended resource monitors (that trigger when any resource becomes
;;; available at any level)m thus allowing resource needs to be
;;; reassessed at a later time.  Note that this scheme for deferring
;;; specification of waited-for resource will depends on resource
;;; monitors not being posted until the end of the action selection
;;; cycle when further interrupts cannot occur (thus triggering
;;; premature specification of needed resource).

;;; ! possible problem: may need to have this function run only if no
;;; new ownerships will be asserted since this can?? trigger new
;;; actions.

(defun generate-int-res-monitors (ints agent)
  (dolist (int-entry ints)  ;;int-entry has form (interrupted <task>)
    (add-apex-resource-monitor
     (make-monitor '(available ?any-resource ?any-level) (second int-entry))
     agent)))

;;; --- Resume-or-engage

;;; Resumes or enables task which has just had required resources
;;; allocated to it.  When a task is unsuspended, all of its suspended
;;; descendants are given a resource grab.

(defun resume-or-engage (task)
  (let ((now (current-time)))
    (case (state task)
      (suspended
       ;; ! Walter
       ;; (and *learning-on* (learn-from-task-state-change task 'ongoing))
       ;; only ongoing tasks may be interrupted
       (record-state-transition task 'ongoing now)
       (cogevent `(resumed ,task) (agent task)
                 :timestamp now)  ;;may need more direct way to
       (attempt-unsuspend-descendants task) ;; trigger descendant res grabs 
       (incf (fragment-number task))
       'ongoing)
      ((pending enabled)
       ;; (engage-task task)
       (transition-task task 'engaged)
       (incf (fragment-number task))
       'ongoing)
      (otherwise nil)))) ;; ! resuming from ongoing WAS an error

(defun attempt-unsuspend-descendants (task)
  (dolist (tk (children task))
    (case (state tk)
      (ongoing 
       (attempt-unsuspend-descendants tk))
      (suspended 
       (when (test-task-preconditions tk)
	 (attempt-resource-grab tk)))
      (t nil))))

;;; -----------------------------------------------------------------------------
;;; ---- Biases
;;; -----------------------------------------------------------------------------

;;; Biases are stored as agent globals (part of the globals slot of an
;;; agent).  Most bindings have the form (<var> . <value>), bias
;;; bindings have the form (<var> :bias <tstart> <duration>). where
;;; tstart is the time of the most recent occurrence of an event making
;;; the correct value of <var> = T; <dur> is the duration of that effect
;;; before <var>'s value reverts to nil.

;;; ---- Handle-Assume-Failure

;;; This function called when an assumption declared in an ASSUME clause
;;; is contradicted by a cogevent.  This should result in the creation
;;; of temporary bias against relying on that assumption when executing
;;; the procedure.  This function produces part of the desired effect by
;;; causing a varibale within the lexical scope of the procedure in
;;; question to become temporarily set to T.  The duration of this
;;; setting and the effect it has on decision-making must be prescribed
;;; inside the procedure.
;;; 
;;; A few odd things about bias variables.  Tasks to monitor for 
;;; violation of assumptions associated with bias vars are generated at
;;; initialization time; the bias vars are thus also generated at that
;;; time and stored as globals (i.e. available to any agent task).
;;; Even though bias vars are stored globally, they are only referred to
;;; by one procedure --- the one whose assume clause generated it.

;;; Note: this function called from built-in PDL procedure

(defun handle-assume-failure (varname agent)
  (let ((bias-binding 
	 (assoc (make-variable varname) (globals agent))))
    (if (not bias-binding)
      (error "Bias variable ~a not in bias memory~%" varname))
    (setf (third bias-binding) (current-time))
    (log-event `(assumption-failed ,varname ,agent) :agent agent)))




;;; ------------------------------------------------------------------
;;; Agenda support
;;; ------------------------------------------------------------------
(defmethod set-tasks ((agent agent) tasks) ; agent * list(task) -> ()
  (setf (tasks (agenda agent)) tasks)
  (loop for task in tasks do
        (setf (agent task) agent)
        ;; parent link
        (setf (containing-agenda task) (agenda agent))
  (values)))

(defmethod tasks ((agent agent))        ; agent -> list(task)
  (tasks (agenda agent)))

(defmethod add-task-if-necessary ((task task) (agent agent))
  ;; task * agent -> ()
  (when (not (member task (tasks (agenda agent))))
    (push task (tasks (agenda agent)))
    (setf (agent task) agent)
    ;; parent link
    (setf (containing-agenda task) (agenda agent)))
  (values))

(defmethod suspended-p ((task task))
  (eql (state task) 'suspended))


;;; ------------------------------------------------------------------
;;; Misc

(defun log+ (x y base) (log (+ (expt base x) (expt base y)) base))

;;; ------------------------------------------------------------------
;;; Transition-related methods (see also task.lisp)
;;; ------------------------------------------------------------------

;;; get or create task state variable
(defmethod task-sv ((task task))
  (if (t-sv task)
    (t-sv task)
    (let ((sv (make-state-variable 'state task)))
      (start-sv-logging-policy (agent-sv-memory (agent task))
			       sv
			       :count-limit most-positive-fixnum)
      (setf (t-sv task) sv)
      sv)))

(defmethod record-task-state ((task task) (state symbol) timestamp)
  (insert-measurement 
   (agent-sv-memory (agent task))
   (make-measurement (task-sv task) state timestamp)
   :warn-if-out-of-order t))

(defmethod record-state-transition ((task task) to-state timestamp
                                  &optional secretly)
  (let ((from-state (state task)))
    (unless (valid-task-transition-p *current-transition-semantics* from-state to-state)
      (error "Invalid state transition from ~S to ~S for ~S [~a]."
	     from-state to-state task *current-transition-semantics*))
    (setf (state task) to-state)
    (unless secretly (record-task-state task to-state timestamp))
    to-state))

